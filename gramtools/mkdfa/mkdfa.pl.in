#!@PERL@
# Copyright (c) 1991-2013 Kawahara Lab., Kyoto University
# Copyright (c) 2000-2005 Shikano Lab., Nara Institute of Science and Technology
# Copyright (c) 2005-2013 Julius project team, Nagoya Institute of Technology
#
# @configure_input@ 
#

## setup
$tmpdir = ".";

# mkfa executable location
($thisdir) = ($0 =~ /(.*(\/|\\))[^\/\\]*$/o);
$mkfabin = "${thisdir}mkfa";
if (! -e $mkfabin) {
    if ($^O eq "MSWin32" || $^O eq "cygwin") {
	$mkfabin .= ".exe";
	if (! -e $mkfabin) {
	    die "cannot find mkfa executable in the script dir";
	}
    } else {
	die "cannot find mkfa executable in the script dir";
    }
}

# dfa_minimize executable location
$minimizebin = "${thisdir}dfa_minimize";
if (! -e $minimizebin) {
    if ($^O eq "MSWin32" || $^O eq "cygwin") {
	$minimizebin .= ".exe";
	if (! -e $minimizebin) {
	    die "cannot find dfa_minimize executable in the script dir";
	}
    } else {
	die "cannot find dfa_minimize executable in the script dir";
    }
}

# dfa_determinize executable location
$determinizebin = "${thisdir}dfa_determinize";
if (! -e $determinizebin) {
    if ($^O eq "MSWin32" || $^O eq "cygwin") {
	$determinizebin .= ".exe";
	if (! -e $determinizebin) {
	    die "cannot find dfa_determinize executable in the script dir";
	}
    } else {
	die "cannot find dfa_determinize executable in the script dir";
    }
}

#############################################################

if ($#ARGV < 0 || $ARGV[0] eq "-h") {
    usage();
}

$make_dict = 1;
$make_term = 1;
$make_forward = 1;

$CRLF = 0;
if ($^O eq "MSWin32") {
    $CRLF = 1;
}

$gramprefix = "";
foreach $arg (@ARGV) {
    if ($arg eq "-t") {
	$make_term = 1;
    } elsif ($arg eq "-n") {
	$make_dict = 0;
    } elsif ($arg eq "-r") {
	$make_forward = 0;
    } else {
	$gramprefix = $arg;
    }
}
if ($gramprefix eq "") {
    usage();
}
$gramfile = "$ARGV[$#ARGV].grammar";
$vocafile = "$ARGV[$#ARGV].voca";
$dfafile  = "$ARGV[$#ARGV].dfa";
$fdfafile  = "$ARGV[$#ARGV].dfa.forward";
$dictfile = "$ARGV[$#ARGV].dict";
$termfile = "$ARGV[$#ARGV].term";
$tmpprefix = "$tmpdir/tmp$$";
$tmpvocafile = "${tmpprefix}.voca";
$rgramfile = "${tmpprefix}-rev.grammar";
$tmpheadfile = "${tmpprefix}.h";

# check if input file exists

if (! -f $gramfile) {
    die "cannot open \"$gramfile\"";
}
if (! -f $vocafile) {
    die "cannot open \"$vocafile\"";
}

# generate reverse grammar file
open(GRAM,"< $gramfile") || die "cannot open \"$gramfile\"";
open(RGRAM,"> $rgramfile") || die "cannot open \"$rgramfile\"";
$n = 0;
while (<GRAM>) {
    chomp;
    s/\r+$//g;
    s/#.*//g;
    if (/^[ \t]*$/) {
	print RGRAM "\n";
	next;
    }
    ($left, $right) = split(/\:/);
    if ($CRLF == 1) {
	print RGRAM $left, ': ', join(' ', reverse(split(/ /,$right))), "\r\n";
    } else {
	print RGRAM $left, ': ', join(' ', reverse(split(/ /,$right))), "\n";
    }
    $n ++;
}
close(GRAM);
close(RGRAM);
print "$gramfile has $n rules\n";

# make temporary voca for mkfa (include only category info)
if (! -r $vocafile) {
	die "cannot open voca file $vocafile";
}
open(VOCA,"$vocafile") || die "cannot open vocabulary file";
open(TMPVOCA,"> $tmpvocafile") || die "cannot open temporary file $tmpvocafile";
if ($make_term == 1) {
    open(GTERM, "> $termfile");
}
$n1 = 0;
$n2 = 0;
$termid = 0;
while (<VOCA>) {
    chomp;
    s/\r+$//g;
    s/#.*//g;
    if (/^[ \t]*$/) {
#	print TMPVOCA "\n";
	next;
    }
    if (/^%[ \t]*([A-Za-z0-9_]*)/) {
	if ($CRLF == 1) {
	    printf(TMPVOCA "\#%s\r\n", $1);
	} else {
	    printf(TMPVOCA "\#%s\n", $1);
	}
	if ($make_term == 1) {
	    if ($CRLF == 1) {
		printf(GTERM "%d\t%s\r\n",$termid, $1);
	    } else {
		printf(GTERM "%d\t%s\n",$termid, $1);
	    }
	    $termid++;
	}
	$n1++;
    } else {
	$n2++;
    }
}
close(VOCA);
close(TMPVOCA);
if ($make_term == 1) {
    close(GTERM);
}
print "$vocafile    has $n1 categories and $n2 words\n";
print "---\n";

# run external command
sub runext {
    my ($command) = @_;
    print "executing [$command]\n";
    $status = system("$command");
    if ($status != 0) {
	print STDERR "\n";
	print STDERR "**** Error occured in mkfa ***\n";
	print STDERR "*  Temporary files are left in $tmpdir for your debugging. You can delete them manually:\n";
	print STDERR "*   reversed grammar = $rgramfile\n";
	print STDERR "*     vocab category = $tmpvocafile\n";
	print STDERR "*         header log = $tmpheadfile\n";
	print STDERR "\n";
    }
    return $status;
}

# execute mkfa
if ($^O eq "cygwin") {
    $com = "$mkfabin -e1 -fg `cygpath -w $rgramfile` -fv `cygpath -w $tmpvocafile` -fo `cygpath -w ${dfafile}.tmp` -fh `cygpath -w $tmpheadfile`";
} else {
    $com = "$mkfabin -e1 -fg $rgramfile -fv $tmpvocafile -fo ${dfafile}.tmp -fh $tmpheadfile";
}
if (&runext($com) != 0) {
    die "stopped";
}
# execute minimize
if ($^O eq "cygwin") {
    $com = "$minimizebin `cygpath -w ${dfafile}.tmp` -o `cygpath -w $dfafile`";
} else {
    $com = "$minimizebin ${dfafile}.tmp -o $dfafile";
}
if (&runext($com) != 0) {
    die "stopped";
}
unlink("${dfafile}.tmp");

print "saved to $dfafile\n";

if ($make_forward == 1) {
    print "---\n";
    print "now reversing $dfafile\n";

    # make forward NFA from DFA
    $dfamax = -1;
    open(DFA,"< $dfafile") || die "cannot open \"$dfafile\"";
    while (<DFA>) {
	chomp;
	s/\r+$//g;
	@a = split(/ /);
	if ($a[1] == -1 && $a[2] == -1) {
	    $endstate[$a[0]] = 1;
	}
	if ($dfamax < $a[0]) {
	    $dfamax = $a[0];
	}
    }
    close(DFA);
    $dfamax += 1;
    open(DFA,"< $dfafile") || die "cannot open \"$dfafile\"";
    open(FDFA,"> ${fdfafile}.tmptmp") || die "cannot open \"${fdfafile}.tmptmp\"";
    if ($CRLF == 1) {
	print FDFA "$dfamax -1 -1 1 0\r\n";
    } else {
	print FDFA "$dfamax -1 -1 1 0\n";
    }
    while (<DFA>) {
	chomp;
	s/\r+$//g;
	@a = split(/ /);
	next if ($a[1] == -1 && $a[2] == -1);
	if ($a[0] == 0) {
	    $a[0] = $dfamax;
	}
	if ($a[2] == 0) {
	    $a[2] = $dfamax;
	}
	if ($a[0] != $dfamax && $endstate[$a[0]] != 0) {
	    $a[0] = 0;
	}
	if ($a[2] != $dfamax && $endstate[$a[2]] != 0) {
	    $a[2] = 0;
	}
	$s = "$a[2] $a[1] $a[0] 0 0";
	if ($CRLF == 1) {
	    print FDFA "$s\r\n";
	} else {
	    print FDFA "$s\n";
	}
    }
    close(DFA);
    close(FDFA);

    # execute determinimize
    if ($^O eq "cygwin") {
	$com = "$determinizebin `cygpath -w ${fdfafile}.tmptmp` -o `cygpath -w ${fdfafile}.tmp`";
    } else {
	$com = "$determinizebin ${fdfafile}.tmptmp -o ${fdfafile}.tmp";
    }
    if (&runext($com) != 0) {
	die "stopped";
    }
    # execute minimize
    if ($^O eq "cygwin") {
	$com = "$minimizebin `cygpath -w ${fdfafile}.tmp` -o `cygpath -w $fdfafile`";
    } else {
	$com = "$minimizebin ${fdfafile}.tmp -o $fdfafile";
    }
    if (&runext($com) != 0) {
	die "stopped";
    }
    unlink("${fdfafile}.tmptmp");
    unlink("${fdfafile}.tmp");
    print "saved to $fdfafile\n";
}

unlink("$rgramfile");
unlink("$tmpvocafile");
unlink("$tmpheadfile");
print "---\n";
if ($status != 0) {
    # error
    print "no .dfa or .dict file generated\n";
    exit;
}

# convert .voca -> .dict
# terminal number should be ordered by voca at mkfa output
if ($make_dict == 1) {
    $nowid = -1;
    open(VOCA, "$vocafile")  || die "No vocafile \"$vocafile\" found.\n";
    open(DICT, "> $dictfile") || die "cannot open $dictfile for writing.\n";
    while (<VOCA>) {
	chomp;
	s/\r//g;
	s/#.*//g;
	if (/^[ \t]*$/) {next;}
	if (/^%/) {
	    $nowid++;
	    next;
	} else {
	    @a = split;
	    $name = shift(@a);
	    if ($CRLF == 1) {
		printf(DICT "%d\t[%s]\t%s\r\n", $nowid, $name, join(' ', @a));
	    } else {
		printf(DICT "%d\t[%s]\t%s\n", $nowid, $name, join(' ', @a));
	    }
	}
    }
    close(VOCA);
    close(DICT);
}

$gene = "$dfafile";
if ($make_term == 1) {
    $gene .= " $termfile";
}
if ($make_dict == 1) {
    $gene .= " $dictfile";
}
$gene .= " $fdfafile";

print "generated: $gene\n";

sub usage {
    print "mkdfa.pl --- DFA compiler\n";
    print "usage: $0 [-n][-r] prefix\n";
    print "\t-n ... keep current dict, not generate\n";
    print "\t-r ... not generate forward grammar\n";
    exit;
}
